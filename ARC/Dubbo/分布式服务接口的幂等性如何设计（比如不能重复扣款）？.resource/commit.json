{"compress":true,"commitItems":[["8f4a4334-a15c-41a5-8824-92bd7b5bdf3c",1571728036577,"",[[1571727978693,["Administrator@zhrb",[[1,0,"# 分布式服务接口的幂等性如何设计（比如不能重复扣款）？\n\n\n\n"]],[0,0],[31,31]]],[1571727986442,["Administrator@zhrb",[[1,31,"从这个问题开始，面试官就已经进入了**实际的生产问题**的面试了。\n\n一个分布式系统中的某个接口，该如何保证幂等性？这个事儿其实是你做分布式系统的时候必须要考虑的一个生产环境的技术问题。啥意思呢？\n\n你看，假如你有个服务提供一些接口供外部调用，这个服务部署在了 5 台机器上，接着有个接口就是**付款接口**。然后人家用户在前端上操作的时候，不知道为啥，总之就是一个订单**不小心发起了两次支付请求**，然后这俩请求分散在了这个服务部署的不同的机器上，好了，结果一个订单扣款扣两次。\n\n或者是订单系统调用支付系统进行支付，结果不小心因为**网络超时**了，然后订单系统走了前面我们看到的那个重试机制，咔嚓给你重试了一把，好，支付系统收到一个支付请求两次，而且因为负载均衡算法落在了不同的机器上，尴尬了。。。\n\n所以你肯定得知道这事儿，否则你做出来的分布式系统恐怕容易埋坑。\n\n## [](https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-idempotency.md#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%96%E6%9E%90)面试题剖析\n\n这个不是技术问题，这个没有通用的一个方法，这个应该**结合业务**来保证幂等性。\n\n所谓**幂等性**，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。\n\n其实保证幂等性主要是三点：\n\n*   对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次，对吧。\n*   每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql 中记录个状态啥的，比如支付之前记录一条这个订单的支付流水。\n*   每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。\n\n实际运作过程中，你要结合自己的业务来，比如说利用 redis，用 orderId 作为唯一键。只有成功插入这个支付流水，才可以执行实际的支付扣款。\n\n要求是支付一个订单，必须插入一条支付流水，order_id 建一个唯一键 `unique key`。你在支付一个订单之前，先插入一条支付流水，order_id 就已经进去了。你就可以写一个标识到 redis 里面去，`set order_id payed`，下一次重复请求过来了，先查 redis 的 order_id 对应的 value，如果是 `payed` 就说明已经支付过了，你就别重复支付了。\n\n*   © 2019 GitHub, Inc."]],[31,31],[1290,1290]]]],null,"Administrator@zhrb"]]}